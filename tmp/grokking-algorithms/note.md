


## 5 hash table

hash table 需要保证每次输入相同的内容返回值都是一样的！

```bash
f(x) = 1 # yes 虽然是每次都返回一样的，但是是符合 hash table 的，输入内容返回值不会变，只不过是一直不会变
f(x) = rand() # no
f(x) = next_empty_slot() # yes
f(x) = len(x) # no
```

### 应用
DNS resolution DNS 解析就是用的 hash table
Cache 缓存使用的也是 hash table

hash 算法是不存在重复的情况，因为用来检查是否又重复项也是非常有用的


### hash function

- 散列函数很重要。前面的散列函数将所有的键都映射到一个位置，而最理想的情况是，散列函数将键均匀地映射到散列表的不同位置。
- 如果散列表存储的链表很长，散列表的速度将急剧下降。然而，如果使用的散列函数很好，这些链表就不会很长！


hash 就是最快的，查询的时候和 array 一样，插入和删除的时候和 linked list 一样快

好的 hash function 都是保证数据是散列在 array 中的，均匀分布，也就是充分利用了空间，但是如果空间不足，比如使用率达到了 0.7 时候，就会动态扩容 1 倍，这个扩容是非常消耗性能的！


## 6 FBS-广度优先搜索

广度优先搜索让**你能够找出两样东西之间的最短距离**，不过最短距离的含义有很多！

使用广度优先搜索可以：
- 编写国际跳棋AI，计算最少走多少步就可获胜；
- 编写拼写检查器，计算最少编辑多少个地方就可将错拼的单词改成正确的单词，如将READED改为READER需要编辑一个地方；
- 根据你的人际关系网络找到关系最近的医生。


前往金门大桥的最短路径需要三步。这种问题被称为最短路径问题（shorterst-pathproblem）。你经常要找出最短路径，这可能是前往朋友家的最短路径，也可能是国际象棋中把对方将死的最少步数。

**解决最短路径问题的算法被称为广度优先搜索。**

解决最短路径问题需要又两个概念：图和广度优先算法

### Graph-图

图是由：图由节点（node）和边（edge）组成。如果 node 之间使用 edge 相连，那么这两个 node 就是邻居

类似下面：*就是 node，---- 就是 edge
*-----*

图是用来模拟不同的东西如何项链的，

### 广度优先算法

广度优先算法是一个基于 Graph 的算法，解决了两个问题，nodeA 到 nodeB 有路径吗？最短路径是什么？

node 和 node 之间是一度关系，而 node 和 node 的 node 就属于二度关系了，依次类推：三度关系、四度关系...

### queue
队列是一种先进先出（First In First Out, FIFO）的数据结构



有向图（directed graph）：没有指向其他人的箭头
无向图（undirected graph）：没有箭头互相连结的 node 就是无向图



### tree-树

没有往回指的边


## 7-狄克斯特拉算法

这也是属于广度优先搜索的算法，但是在寻找最短路径的时候是加了权重的，权重就是：狄克斯特拉算法用于每条边都有关联数字的图，这些数字称为权重（weight）

带权重的图称为加权图（weighted graph），不带权重的图称为非加权图（unweighted graph）。



